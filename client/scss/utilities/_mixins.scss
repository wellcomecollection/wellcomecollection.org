@mixin respond-to($point, $condition: min-width) {
  // Ensure media query isn't in quotes
  $condition: unquote($condition);
  // Check global breakpoints first
  @if map-has-key($breakpoints, $point) {
    @media ($condition: map-get($breakpoints, $point)) {
      @content;
    }
    // Failing that, check local tweakpoints
  } @else if map-has-key($tweakpoints, $point) {
    @media ($condition: map-get($tweakpoints, $point)) {
      @content;
    }
  } @else {
    @warn 'Could not find `#{$point}` in both local ($tweakpoints) and global ($breakpoints) contexts. Media block omitted.';
  }
}

@mixin respond-between($point1, $point2) {
  // Check global breakpoints first
  @if map-has-key($breakpoints, $point1) and map-has-key($breakpoints, $point2) {
    @media (min-width: map-get($breakpoints, $point1)) and (max-width: map-get($breakpoints, $point2) - 1) {
      @content;
    }
    // Failing that, check local tweakpoints
  } @else if map-has-key($tweakpoints, $point1) {
    @media (min-width: map-get($tweakpoints, $point1)) and (max-width: map-get($tweakpoints, $point2) - 1) {
      @content;
    }
  } @else {
    @warn 'Could not find `#{$point1}` and/or `#{$point2}` in both local ($tweakpoints) and global ($breakpoints) contexts. Media block omitted.';
  }
}

@mixin container-query($cq-list) {
  @each $sizes in $cq-list {
    $size-key: nth($sizes, 1);
    $size: map-get($grid-config, $size-key);
    $respond: map-get($size, 'respond');
    $col-suffix: null;

    @if (length($respond) > 1) {
      @for $i from 1 through nth($sizes, 2) {
        $col-suffix: #{$col-suffix}#{$i};
      }

      // stylelint-disable plugin/declaration-block-order
      @include respond-between(nth($respond, 1), nth($respond, 2)) {
        [class*='grid__cell--#{$size-key}#{$col-suffix}'] & {
          @content;
        }
      }
    } @else {
      @for $i from 1 through nth($sizes, 2) {
        $col-suffix: #{$col-suffix}#{$i};
      }

      @include respond-to($respond) {
        [class*='grid__cell--#{$size-key}#{$col-suffix}'] & {
          @content;
        }
      }
      // stylelint-enable plugin/declaration-block-order
    }
  }
}

@mixin clearfix {
  &:before,
  &:after {
    content: '';
    display: table;
  }

  &:after {
    clear: both;
  }
}

@mixin plain-list() {
  list-style: none;
  margin: 0;
  padding: 0;
}

@mixin grid-cells($columns, $key) {
  @for $i from 1 through $columns {
    $col-suffix: null;

    @for $j from 1 through $i {
      $col-suffix: #{$col-suffix}#{$j};
    }

    .grid__cell--#{$key}#{$col-suffix} {
      flex-basis: ($i / $columns) * 100%;
      max-width: ($i / $columns) * 100%;
    }

    .grid__cell--shift-#{$key}#{$col-suffix} {
      margin-left: ($i / $columns) * 100%;
    }
  }
}

@mixin font($font-name) {
  $font: map-get($fonts, $font-name);

  $font-family-base: map-get($font, 'font-family-base');
  $font-family-subset: map-get($font, 'font-family-subset');
  $font-family-web: map-get($font, 'font-family-web');
  $font-size: px-to-rem(map-get($font, 'font-size'));
  $letter-spacing: tracking-to-em(map-get($font, 'letter-spacing'));
  $line-height: px-to-unitless(map-get($font, 'line-height'), map-get($font, 'font-size'));

  font-family: $font-family-base;
  font-size: $font-size;
  letter-spacing: $letter-spacing;
  line-height: $line-height;

  @if($font-family-subset) {
    .font-stage-1 & {
      font-family: #{$font-family-subset + ',' + $font-family-base};
    }
  }

  @if($font-family-web and $font-family-subset) {
    .font-stage-2 & {
      font-family: #{$font-family-web + ',' + $font-family-subset + ',' + $font-family-base};
    }
  } @else if ($font-family-web) {
    .font-stage-2 & {
      font-family: #{$font-family-web + ',' + $font-family-base};
    }
  }
}

// Allow an element to be horizontally stretched outwith its container
@mixin bleed($amount, $with-padding: false) {
  margin-left: -$amount;
  margin-right: -$amount;

  @if ($with-padding) {
    padding-left: $amount;
    padding-right: $amount;
  }
}

@mixin visually-hidden {
  border: 0;
  clip: rect(0 0 0 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
  white-space: nowrap;
}

@mixin visually-hidden-focusable {
  &:active,
  &:focus {
    clip: auto;
    height: auto;
    margin: 0;
    overflow: visible;
    position: static;
    width: auto;
    white-space: inherit;
  }
}

@mixin hover-bounce {
  animation-duration: 400ms;
  animation-name: hover-bounce;
}

@keyframes hover-bounce {
  0% {
    top: 0;
    animation-timing-function: ease-in;
  }

  50% {
    top: -0.4em;
    animation-timing-function: ease-out;
  }

  100% {
    top: 0;
  }
}
